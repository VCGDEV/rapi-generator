package {basePackage}.{servicePackage}.impl;

import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.hateoas.Resource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.http.HttpStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;
import {basePackage}.{servicePackage}.{entityName}Service;
import {basePackage}.{exceptionPackage}.{Exception};
import {basePackage}.{dtoPackage}.{dtoName};
import {basePackage}.{repositoryPackage}.{entityName}Repository;
import {basePackage}.{domainPackage}.{entityName};
import org.springframework.dao.DataIntegrityViolationException;
/**
* Versions 1.0
* Created using Rest API Generator
* Basic CRUD service
*/
@Service
@Transactional(readOnly = true)
public class {entityName}ServiceImpl implements {entityName}Service {

    private final Logger logger = LoggerFactory.getLogger({entityName}ServiceImpl.class);

    private {entityName}Repository {entityVar}Repository;

    //TODO add attributes to order paginated result
    private final Map<String,Object> columnNames = new HashMap<>();

    @Autowired
    public void set{entityName}Repository({entityName}Repository {entityVar}Repository){
        this.{entityVar}Repository = {entityVar}Repository;
    }

    /**
    * Method to add new {entityName} in database
    * @param {dtoVar} the values to be saved
    * @throws {Exception} if an error happens in transaction
    */
    @Transactional(rollbackFor={Exception}.class)
    public Resource<{classId}> add{entityName}({dtoName} {dtoVar}) throws {Exception}{
        try{
            {entityName} {entityVar} = mapFromDTO({dtoVar});
            {entityVar}Repository.save({entityVar});
            return new Resource<>({entityVar}.getId());
        }catch(DataIntegrityViolationException dve){
            logger.error("Error in insert transaction",dve);
            throw new {Exception}("Error in insert transaction",HttpStatus.INTERNAL_SERVER_ERROR);
        }catch(Exception ex){
            logger.error("Not managed error in insert transaction",ex);
            throw new {Exception}("Internal server error",HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
    * Method to update values of entity
    * @param {dtoVar} the values to update
    * @throws {Exception} if an error happens in transaction
    */
    @Transactional(rollbackFor={Exception}.class)
    public Resource<{classId}> update{entityName}({dtoName} {dtoVar}) throws {Exception} {
        try{
            if(!{entityVar}Repository.existsById({dtoVar}.getId())){
                logger.error("Entity not exists in database - ID: {}",{dtoVar}.getId());
                throw new {Exception}("Object does not exist",HttpStatus.NOT_FOUND);
            }
            {entityName} {entityVar} = mapFromDTO({dtoVar});
            {entityVar}Repository.save({entityVar});
            return new Resource<{classId}>({entityVar}.getId());
        }catch({Exception} xe){
            throw xe;
        }catch(Exception ex){
            logger.error("Not managed error in insert transaction",ex);
            throw new {Exception}("Internal server error",HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
    * Get details of {entityName}
    * @param id unique identifier to find object
    * throws {Exception} if an error happens in select transaction
    */
    public Resource<{dtoName}> findById({classId} id) throws {Exception}{
        try{
            if(!{entityVar}Repository.existsById(id)){
                logger.error("Entity not exists in database - ID: {}",id);
                throw new {Exception}("Object does not exist",HttpStatus.NOT_FOUND);
            }
            {dtoName} {dtoVar} = mapFromEntity({entityVar}Repository.getOne(id));
            Resource<{dtoName}> resource = new Resource<>({dtoVar});
            return resource;
        }catch({Exception} excp){
            throw excp;
        }catch(Exception ex){
            logger.error("Not managed error in select transaction",ex);
            throw new {Exception}("Internal server error",HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
    * Get List of all {entityName}
    * throws {Exception} if an error happens in select transaction
    */
    public List<Resource<{dtoName}>> findAll() throws {Exception}{
        try{
            return {entityVar}Repository.findAll()
            .stream()
            .map(e -> new Resource<{dtoName}>(mapFromEntity(e)))
            .collect(Collectors.toList());
        }catch(Exception ex){
            logger.error("Not managed error in select transaction");
                        throw new {Exception}("Internal server error",HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
    * Get paginated result
    * @param page -> the page to be extracted from database
    * @param size -> the size of dataset
    * @param columnToOrder -> The column to sort result
    * @param orderType -> values {'DESC','ASC'}
    * @return the page obtained from database
    * @throws {Exception} if an error happens in query select
    */
    public Page<Resource<{dtoName}>> getPaginatedResult(
            Integer page,Integer size,String columnToOrder, String orderType
        ) throws {Exception} {
            try {
                Sort sort = new Sort(Sort.Direction.ASC, (String) columnNames.get("id"));
                if (columnToOrder != null && orderType != null) {
                    if (orderType.equalsIgnoreCase("asc")) {
                        sort = new Sort(Sort.Direction.ASC, (String) columnNames.get(columnToOrder));
                    }else {
                        sort = new Sort(Sort.Direction.DESC, (String) columnNames.get(columnToOrder));
                    }
                }
                PageRequest request = PageRequest.of(page, size, sort);
                Page<{entityName}> {entityVar}Page = {entityVar}Repository.findAll(request);
                List<Resource<{dtoName}>> resourcesList = userPage.getContent()
                                    .stream()
                                    .map(e -> new Resource(mapFromEntity(e)))
                                    .collect(Collectors.toList());
                return new PageImpl<>(resourcesList, request, {entityVar}Page.getTotalElements());
            }catch (Exception ex){
                logger.error("Not managed error in select transaction",ex);
                throw new BaseException("Internal server error",HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

    private {entityName} mapFromDTO({dtoName} {dtoVar}){
        {entityName} {entityVar} = new {entityName}();
{dtoMapping}
        return {entityVar};
    }

    private {dtoName} mapFromEntity({entityName} {entityVar}){
        {dtoName} {dtoVar} = new {dtoName}();
{entityMapping}
        return {dtoVar};
    }
}